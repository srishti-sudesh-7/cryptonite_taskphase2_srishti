# buffer overflow 0

*Flag:* picoCTF{ov3rfl0ws_ar3nt_that_bad_9f2364bc}

Procedure
- first I downloaded the source file and program.
- on running the challenge, it said I had to connect using `nc saturn.picoctf.net 64681`, so I did the same. on doing so, it asked me for an input so I just gave a random input to see what happens:
  ![Screenshot 2024-11-06 100703](https://github.com/user-attachments/assets/144244da-cb53-4da8-a227-a29c46001e76)
- since I couldnt gather much from running the file, I took a look at the source code.
- in this I observed that a function called vuln was being used to copy the user's input into a buffer string:
  ![image](https://github.com/user-attachments/assets/1da8f38e-306d-4434-9628-14b165627a79)
- since the buffer string was declared to store only 16 characters, I tried putting more than 16 characters as input and this worked!
  I did have to restart the instance using `nc saturn.picoctf.net 63526` though:
  
  ![image](https://github.com/user-attachments/assets/7fe3b7ce-fd62-4b8e-a550-6a1b57fc3685)

- I still didnt fully understand why this worked, so I looked into the code again.
- it was obvious that the sigsegv_handler function was responsible for printing the flag:

  ![image](https://github.com/user-attachments/assets/ed8b4939-3393-4cc5-8cca-611ebd240d2a)

- using a reference, I learnt that `signal(SIGSEGV, sigsegv_handler);` basically tells the machine to execute sigsegv_handler when it encounters a SIGSEGV signal (signal for segmentation fault).
- now I understood why my method worked. overflowing the buffer resulted in a segmentation fault, which then triggered the sigsegv_handler function to print the flag.

Learnings
- function of fflush(stdout) - it flushes out the output buffer into the console.
- a little bit about signal handling - signals are a way for the OS/process to send a message to a program, indicating that a specific event has occurred.

References:
- https://www.tutorialspoint.com/c_standard_library/c_function_signal.htm
- https://www.geeksforgeeks.org/signals-c-language/


# format string 0
*Flag:* picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_63191ce6}

Procedure
- I started with downloading the binary file and c file.
- on looking through the c file, I noticed this particular piece of code in the function servepatrick(): 

![image](https://github.com/user-attachments/assets/a657c4f1-e780-4e43-897d-5be7888e28c4)

- here the if statement at line 69 suggests that if count (no. of characters in the choice entered by user) is greater than twice the BUFSIZE, patrick will be satisfied and it'll move on to Bob:
- given that BUFSIZE=32,
![image](https://github.com/user-attachments/assets/9e2799d0-b6cf-4fe6-a3aa-d310b7c39480)
 therefore, the choice entered by user must take more than 64 bytes of space.
- but "Breakf@st_Burger" has 16 characters, "Gr%114d_Cheese" has 13 characters, and "Bac0n_D3luxe" also has 13 characters. however, because %114d in "Gr%114d_Cheese" is a format specifier for 114 characters, it expects an integer with 114 characters. since it doesn't get the expected value, it will give a garbage value of 114 chars, which fulfills the if condition and moves on to the next function.
- for the second customer, these were the options: "Pe%to_Portobello", "$outhwest_Burger", "Cla%sic_Che%s%steak"
  ![image](https://github.com/user-attachments/assets/ed56e4ad-fa10-41fa-b1fa-6ecd239b144d)
  
- since Cla%sic_Che%s%steak has string format specifier %s, the printf statement will try to print a string, however since there's no string argument, it causes an error which triggers the flag to be displayed.

terminal output:
![image](https://github.com/user-attachments/assets/b714c843-c59c-4953-a24f-f61cc79d7f83)

Learnings
- learnt more about format specifiers

References
- https://book.hacktricks.xyz/binary-exploitation/format-strings


# flag leak

*Flag:*

Procedure
- first I connected to the challenge server and this is the prompt that came:
  ![image](https://github.com/user-attachments/assets/5c2b8edb-1468-447a-8569-277b25441608)
- I then opened the source code and went through the vulnerable function:
  ![image](https://github.com/user-attachments/assets/75d894c9-4f93-4036-b3cd-6f3866146133)
- I noticed that the string could take only 127 characters so I tried entering more chars than that, but this did not work as it copy-pasted only the first 127 characters of my input
  ![image](https://github.com/user-attachments/assets/b6bb8945-1543-4689-92bb-db23bb66d7cc)
- as I scanned the source code again, I realised that the printf function was missing a format specifier
  ![image](https://github.com/user-attachments/assets/c6ee60d8-0860-4c58-bc51-5f0e0e5eb524)
- so I searched up how to take advantage of such vulnerabilities. I learnt that if there is no format specifier, I could enter my own format specifier and manipulate the program to print the flag.
- for this, I would require the exact address of the flag in the stack, to find this I used gdb. the commands I entered in order are
   - `gdb vuln` to open the vuln program
   - `info functions` to get all the functions present in the program
   - `disassemble vuln` to get the assembly language of the vuln function
  ![image](https://github.com/user-attachments/assets/56982c24-43f5-43dc-b963-7c82b67a4149)
  ![image](https://github.com/user-attachments/assets/8dd3417f-6370-470b-8ab0-c981e6e8769e)
- I learnt about breakpoints and their usage. They are used to stop and resume the program. so, I needed to set a breakpoint right after the readflag function is called, which is marked at address `0x0804935a`
  ![image](https://github.com/user-attachments/assets/094f7682-0202-457b-9941-099a0d03ae46)
- to set breakpoint, the format is: break *_address_
![image](https://github.com/user-attachments/assets/8fd2bd24-5c75-45d7-a873-ab95b5e8404e)
- now I ran the program to see the stack
- 


References:
- https://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_28.html          
- https://developer.apple.com/library/archive/documentation/DeveloperTools/gdb/gdb/gdb_6.html#:~:text=A%20breakpoint%20makes%20your%20program,detail%20whether%20your%20program%20stops.
