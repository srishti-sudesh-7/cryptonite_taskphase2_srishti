# buffer overflow 0

*Flag:* picoCTF{ov3rfl0ws_ar3nt_that_bad_9f2364bc}

Procedure
- first I downloaded the source file and program.
- on running the challenge, it said I had to connect using `nc saturn.picoctf.net 64681`, so I did the same. on doing so, it asked me for an input so I just gave a random input to see what happens:
  ![Screenshot 2024-11-06 100703](https://github.com/user-attachments/assets/144244da-cb53-4da8-a227-a29c46001e76)
- since I couldnt gather much from running the file, I took a look at the source code.
- in this I observed that a function called vuln was being used to copy the user's input into a buffer string:
  ![image](https://github.com/user-attachments/assets/1da8f38e-306d-4434-9628-14b165627a79)
- since the buffer string was declared to store only 16 characters, I tried putting more than 16 characters as input and this worked!
  I did have to restart the instance using `nc saturn.picoctf.net 63526` though:
  
  ![image](https://github.com/user-attachments/assets/7fe3b7ce-fd62-4b8e-a550-6a1b57fc3685)

- I still didnt fully understand why this worked, so I looked into the code again.
- it was obvious that the sigsegv_handler function was responsible for printing the flag:

  ![image](https://github.com/user-attachments/assets/ed8b4939-3393-4cc5-8cca-611ebd240d2a)

- using a reference, I learnt that `signal(SIGSEGV, sigsegv_handler);` basically tells the machine to execute sigsegv_handler when it encounters a SIGSEGV signal (signal for segmentation fault).
- now I understood why my method worked. overflowing the buffer resulted in a segmentation fault, which then triggered the sigsegv_handler function to print the flag.

Learnings
- function of fflush(stdout) - it flushes out the output buffer into the console.
- a little bit about signal handling - signals are a way for the OS/process to send a message to a program, indicating that a specific event has occurred.

References:
- https://www.tutorialspoint.com/c_standard_library/c_function_signal.htm
- https://www.geeksforgeeks.org/signals-c-language/


# format string 0
*Flag:* picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_63191ce6}

Procedure
- I started with downloading the binary file and c file.
- on looking through the c file, I noticed this particular piece of code in the function servepatrick(): 

![image](https://github.com/user-attachments/assets/a657c4f1-e780-4e43-897d-5be7888e28c4)

- here the if statement at line 69 suggests that if count (no. of characters in the choice entered by user) is greater than twice the BUFSIZE, patrick will be satisfied and it'll move on to Bob:
- given that BUFSIZE=32,
![image](https://github.com/user-attachments/assets/9e2799d0-b6cf-4fe6-a3aa-d310b7c39480)
 therefore, the choice entered by user must take more than 64 bytes of space.
- but "Breakf@st_Burger" has 16 characters, "Gr%114d_Cheese" has 13 characters, and "Bac0n_D3luxe" also has 13 characters. however, because %114d in "Gr%114d_Cheese" is a format specifier for 114 characters, it expects an integer with 114 characters. since it doesn't get the expected value, it will give a garbage value of 114 chars, which fulfills the if condition and moves on to the next function.
- for the second customer, these were the options: "Pe%to_Portobello", "$outhwest_Burger", "Cla%sic_Che%s%steak"
  ![image](https://github.com/user-attachments/assets/ed56e4ad-fa10-41fa-b1fa-6ecd239b144d)
  
- since Cla%sic_Che%s%steak has string format specifier %s, the printf statement will try to print a string, however since there's no string argument, it causes an error which triggers the flag to be displayed.

terminal output:
![image](https://github.com/user-attachments/assets/b714c843-c59c-4953-a24f-f61cc79d7f83)

Learnings
- learnt more about format specifiers

References
- https://book.hacktricks.xyz/binary-exploitation/format-strings


# flag leak

*Flag:* picoCTF{L34K1ng_Fl4g_0ff_St4ck_999e2824}

Procedure
- first I connected to the challenge server and this is the prompt that came:
  ![image](https://github.com/user-attachments/assets/5c2b8edb-1468-447a-8569-277b25441608)
- I then opened the source code and went through the vulnerable function:
  ![image](https://github.com/user-attachments/assets/75d894c9-4f93-4036-b3cd-6f3866146133)
- I noticed that the string could take only 127 characters so I tried entering more chars than that, but this did not work as it copy-pasted only the first 127 characters of my input
  ![image](https://github.com/user-attachments/assets/b6bb8945-1543-4689-92bb-db23bb66d7cc)
- as I scanned the source code again, I realised that the printf function was missing a format specifier
  ![image](https://github.com/user-attachments/assets/c6ee60d8-0860-4c58-bc51-5f0e0e5eb524)
- so I searched up how to take advantage of such vulnerabilities. I learnt that if there is no format specifier, I could enter my own format specifier and manipulate the program to print the flag. to do this I needed to use format specifier "%x" (for hex) to climb up the stack and see if I can find anything useful.
- so I tried overflowing with "%x.":
  ![image](https://github.com/user-attachments/assets/663e4cff-47a8-4548-ab30-a14b9bcab848)
- I fed these values into a Hex-to-ASCII converter (CyberChef)
![image](https://github.com/user-attachments/assets/102a607a-1237-478a-abd8-63a9a401b525)
- I seemed to make some progress since a strin of characters resembling the flag was found, however there were 2 problems: (a) the characters were jumbled and (b) I didn't have the second half of characters (as } was missing)
- I didnt know how to climb further up the stack so I had to look it up.
- I found that I could use a particular number as an argument for the format specifier, which would make it print only that part of the string. since it already printed 43 characters, I started from 40:
  ![image](https://github.com/user-attachments/assets/dca39a64-5e76-4386-87d8-e4d35e31ce89)
- I put this pattern in the converter again and got the complete jumbled flag:
  ![image](https://github.com/user-attachments/assets/28dc8f22-5654-443e-9d4d-83b51b30e018)
- from the usual pattern that the flag has, I=it was obvious that every 4 letters in this jumbled string was reversed, so I reversed every 4 letters of `ocip{FTCk43L_gn1g4lFff0_4tS_9_kc2e99}428` and got the flag

  
References:
https://www.geeksforgeeks.org/printf-in-c/
