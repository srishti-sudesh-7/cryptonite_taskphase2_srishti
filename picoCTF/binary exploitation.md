# buffer overflow 0

*Flag:* picoCTF{ov3rfl0ws_ar3nt_that_bad_9f2364bc}

Procedure
- first I downloaded the source file and program.
- on running the challenge, it said I had to connect using `nc saturn.picoctf.net 64681`, so I did the same. on doing so, it asked me for an input so I just gave a random input to see what happens:
  ![Screenshot 2024-11-06 100703](https://github.com/user-attachments/assets/144244da-cb53-4da8-a227-a29c46001e76)
- since I couldnt gather much from running the file, I took a look at the source code.
- in this I observed that a function called vuln was being used to copy the user's input into a buffer string:
  ![image](https://github.com/user-attachments/assets/1da8f38e-306d-4434-9628-14b165627a79)
- since the buffer string was declared to store only 16 characters, I tried putting more than 16 characters as input and this worked!
  I did have to restart the instance using `nc saturn.picoctf.net 63526` though:
  
  ![image](https://github.com/user-attachments/assets/7fe3b7ce-fd62-4b8e-a550-6a1b57fc3685)

- I still didnt fully understand why this worked, so I looked into the code again.
- it was obvious that the sigsegv_handler function was responsible for printing the flag:

  ![image](https://github.com/user-attachments/assets/ed8b4939-3393-4cc5-8cca-611ebd240d2a)

- using a reference, I learnt that `signal(SIGSEGV, sigsegv_handler);` basically tells the machine to execute sigsegv_handler when it encounters a SIGSEGV signal (signal for segmentation fault).
- now I understood why my method worked. overflowing the buffer resulted in a segmentation fault, which then triggered the sigsegv_handler function to print the flag.

Learnings
- function of fflush(stdout) - it flushes out the output buffer into the console.
- a little bit about signal handling - signals are a way for the OS/process to send a message to a program, indicating that a specific event has occurred.

References:
- https://www.tutorialspoint.com/c_standard_library/c_function_signal.htm
- https://www.geeksforgeeks.org/signals-c-language/


# format string 0
*Flag:* picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_63191ce6}

Procedure
- I started with downloading the binary file and c file.
- on looking through the c file, I noticed this particular piece of code in the function servepatrick(): 

![image](https://github.com/user-attachments/assets/a657c4f1-e780-4e43-897d-5be7888e28c4)

- here the if statement at line 69 suggests that if count (no. of characters in the choice entered by user) is greater than twice the BUFSIZE, patrick will be satisfied and it'll move on to Bob:
- given that BUFSIZE=32,
![image](https://github.com/user-attachments/assets/9e2799d0-b6cf-4fe6-a3aa-d310b7c39480)
 therefore, the choice entered by user must take more than 64 bytes of space.
- but "Breakf@st_Burger" has 16 characters, "Gr%114d_Cheese" has 13 characters, and "Bac0n_D3luxe" also has 13 characters. however, because %114d in "Gr%114d_Cheese" is a format specifier for 114 characters, it expects an integer with 114 characters. since it doesn't get the expected value, it will give a garbage value of 114 chars, which fulfills the if condition and moves on to the next function.
- for the second customer, these were the options: "Pe%to_Portobello", "$outhwest_Burger", "Cla%sic_Che%s%steak"
  ![image](https://github.com/user-attachments/assets/ed56e4ad-fa10-41fa-b1fa-6ecd239b144d)
  
- since Cla%sic_Che%s%steak has string format specifier %s, the printf statement will try to print a string, however since there's no string argument, it causes an error which triggers the flag to be displayed.

terminal output:
![image](https://github.com/user-attachments/assets/b714c843-c59c-4953-a24f-f61cc79d7f83)

Learnings
- learnt more about format specifiers

References
- https://book.hacktricks.xyz/binary-exploitation/format-strings
